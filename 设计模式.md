### 1、简单工厂模式

由工厂类产生响应的类，把类交给工厂去处理不需要自己去手动去new，降低了代码之间的耦合度，提高了代码的复用，然后去调用相应的逻辑

```java
/**
计算器的实现
第一步首先有一个加减乘除的抽象类
*/
public abstract class Operation {
    private double firstNum;
    private double lastNum;
    private double result;
    public abstract double getResult();
    public double getFirstNum() {
        return firstNum;
    }
    public void setFirstNum(double firstNum) {
        this.firstNum = firstNum;
    }

    public double getLastNum() {
        return lastNum;
    }

    public void setLastNum(double lastNum) {
        this.lastNum = lastNum;
    }
}
/**
第二步设计一个计算机工厂
**/
public class OperationFactory {
    public static Operation createOperation(String operation){
        switch (operation){
            case "+":
                return new AddOperation();
            case "-":
                return new SubOperation();
            case "*":
                return new MulOperation();
            case "/":
                return new DivOperation();
            default:
                return null;
        }
    }
}
/**
第三部计算器的实现类
*/
public class AddOperation extends Operation{

    @Override
    public double getResult() {
        return getFirstNum()+getLastNum();
    }
}

public  class DivOperation extends Operation{

    @Override
    public double getResult() {
        if(getLastNum()!=0) {
            return getFirstNum() / getLastNum();
        }
        return 0d;
    }
}
/**
测试类（通过给工厂传入值 工厂决定生产什么对象）
*/
public class Main {
    public static void main(String[] args) {
        double firstNum,lastNum;
        String operator;
        Scanner scanner = new Scanner(System.in);
        firstNum = scanner.nextDouble();
        lastNum = scanner.nextDouble();
        operator = scanner.nextLine();
        Operation operation = OperationFactory.createOperation(operator.trim());
        operation.setFirstNum(firstNum);
        operation.setLastNum(lastNum);
        System.out.println(operation.getResult());
    }
}
```

### 2、策略设计模式

上下文类去指定某个类去做响应的操作，通过策略类来对一些算法进行响应的封装与扩展。传统的策略模式生成类的职责还是由客户端产生，可以把策略模式结合工厂模式一起使用。

```java
/**
策略类
*/
public abstract class Strategy{
    //算法方法
    public abstract void method();
}

/**
策略实现A类
*/
public class ConcreteStrategyA extend Strategy{
    //算法实现
    public void method(){};
}

/**
策略实现B类
*/
public class ConcreteStrategyB extend Strategy{
    //算法实现
    public void method(){};
}

/**
策略实现上下文类
*/
public class Context{
    Strategy strategy;
    //传入策略实现类
    public Context(Strategy strategy){
        this.strategy = strategy;
    }
    //上下文接口
    public void ContextInterface(){
        strategy.method();
    }
}

/**
测试类
*/
public class Test{
    public static void main(String[] args) {
        //传统的生成策略类的职责还是交给了客户端。
        Context context = new Context(new ConcreteStrategyA());
        //将策略模式结合传统工厂模式一起使用,将生成策略类的职责交给工厂。
        Strategy strategy = Factory.create();
        Context context = new Context(strategy);
        context.ContextInterface();
    }
}
```

### 3、装饰设计模式

动态地给对象添加一些额外的职责，就功能来说，装饰模式比生成子类更加灵活。

```java
//首先定义一个Component接口可以给这些对象动态的添加职责
public abstract class Component{
    public abstract void Operation();
}
//定义一个具体的对象，也可以给这个对象动态的添加一些职责
public class ConcreteComponent extends Component{
    //具体的操作
    public void Operation(){
        
    }
}
//定义一个装饰类
public abstract class Decorator extends Component{
    protected Component component;
    
    public void setComponent(Component component){
        this.component = component;
    }
    @Override
    public void Operation(){
        if(null!=component){
            component.Operation();
        }
    }
}
//装饰类的实现类
public class ConcreteDecoratorA extends Decorator{
    private String addedState;

    @Override
    public void operation() {
        super.operation();
        addedState="New State";
        System.out.println("具体装饰对象A的操作");
    }
}

public class ConcreteDecoratorB extends Decorator{

    @Override
    public void operation() {
        super.operation();
        AddBehaviour();
        System.out.println("具体装饰对象B的操作");
    }

    public void AddBehaviour(){
        System.out.println("B的行为");
    }
}
//测试类
//子类继承父类的component，设置子类的Component去循环调用component的实现方法
public class Test {
    public static void main(String[] args) {
        ConcreteComponent c = new ConcreteComponent();
        ConcreteDecoratorA a = new ConcreteDecoratorA();
        ConcreteDecoratorB b = new ConcreteDecoratorB();
        a.setComponent(c);
        b.setComponent(a);
        b.operation();
    }
}


```

### 4、代理设计模式

为其他对象提供一个代理类以控制这个对象的访问。

```java
//定义公用接口类
public abstract class Subject {
    public abstract void Request();
}
//代理类
public class Proxy extends Subject{
	//代理的真实对象
    private RealSubject realSubject;

    public Proxy(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void Request() {
        realSubject.Request();
    }
}
//真实对象类
public class RealSubject extends Subject{

    @Override
    public void Request() {
        System.out.println("真正的请求");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
    	Proxy proxy = new Proxy();
        proxy.Request();
    }
}


```

### 5、工厂方法模式

**工厂方法模式**：定义一个创建对象的接口，让子类去决定实例化哪一个类。工厂方法使一个类的实例化延时到子类。工厂方法和简单工厂最大的区别在于，简单工厂每次增加新的功能类的时候需要去工厂里加新的方法，违背了开闭原则。工厂方法模式，只需要创建对应的工厂和对应的子类。降低了工厂和实体类之间的代码的耦合性。

```java
//定义一个工厂抽象类
public interface IFactory{
    Operation createOperation();
}
//定义实体工厂 负责生产对应的类
public class AddFactory extends IFactory{
      Operation createOperation(){
          return new OperationAdd();
      }
}
public class MulFactory extends IFactory{
      Operation createOperation(){
          return new OperationMul();
      }
}
//运算抽象接口
public interface Operation{
    void operation();
}
//具体子类实现
public class AddOperation extends Operation{
    //具体实现
    void operation(){
        
    }
}
public class MulOperation extends Operation{
    //具体实现
    void operation(){
        
    }
}
```

### 6、原型模式

**原型模式**：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何细节。

**参考：**https://blog.csdn.net/qq_36940806/article/details/80193384

```java
//原型类 java一定要实现Cloneable，不然clone方法会报错 clone方法是浅拷贝
//浅拷贝只拷贝值
public abstract class Prototype implements Cloneable{
    private String id;

    public Prototype(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }

    @Override
    public String toString() {
        return "Prototype{" +
                "id='" + id + '\'' +
                '}';
    }

    public void setId(String id) {
        this.id = id;
    }
    //定义一个克隆自己的方法
    public abstract Prototype clonePrototype();
}
//原型实现类
public class ConcretePrototypeA extends Prototype{
	
    public ConcretePrototypeA(String id) {
        super(id);
    }

    @Override
    public ConcretePrototypeA clonePrototype() {
        try {
            return (ConcretePrototypeA) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return new ConcretePrototypeA("克隆失败");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        ConcretePrototypeA c = new ConcretePrototypeA("1");
        ConcretePrototypeA c1 = (ConcretePrototypeA) c.clonePrototype();
        System.out.println(c);
        System.out.println(c1);
    }
}
//深拷贝 拷贝对象的引用的地址
public class Address implements Cloneable{
    private String location;

    public Address(String location){
        this.location=location;
    }
    public String getLocation() {
        return location;
    }
    public void setLocation(String location) {
        this.location=location;
    }
    public Address Clone(){
        Address a=null;
        try {
            a =  (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return a;
    }
}
public class Student implements Cloneable {
    public String name;
    public Address address;

    public Student(String name, Address address) {

        super();
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Student Clone(){
        Student s = null;
        try {
            s = (Student) super.clone();
            s.address = address.Clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return s;
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Address address = new Address("北京");
        Student s = new Student("张三", address);
        Student sclone = (Student) s.Clone();
        System.out.println("学生姓名：" + s.getName() + "   克隆学生姓名：" + sclone.getName());
        System.out.println("学生地址：" + s.address.getLocation() + "   克隆学生地址：" + sclone.address.getLocation());
        System.out.println("两个学生对象"+(s.address == sclone.address?"相同":"不同"));  //测试被可伶的对象与原对象是否是同一个对象
        System.out.println("修改被克隆学生姓名为李四，地址为四川，");
        s.setName("李四");
        s.address.setLocation("四川");
        System.out.println("学生姓名：" + s.getName() + "   克隆学生姓名：" + sclone.getName());
        System.out.println("学生地址：" + s.address.getLocation() + "   克隆学生地址：" + sclone.address.getLocation());
        // 浅复制只复制值类型的变量和对对象的引用
        // 深复制不仅复制值类型的变量，把原对象引用的对象也进行复制.
    }
}

//完全拷贝 采用序列化的方式把对象写入流中 再从流中读取
public class Author implements Serializable {

    /**
     *
     */
    private static final long serialVersionUID = 2719717328965672807L;

    private String name;
    Address address;

    public Author(String name, Address address) {
        super();
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
    // 使用序列化技术实现完全拷贝

    public Author absoluteClone() throws IOException, ClassNotFoundException {

        // 将对象写入流中

        ByteArrayOutputStream bao = new ByteArrayOutputStream();

        ObjectOutputStream oos = new ObjectOutputStream(bao);

        oos.writeObject(this);

        // 将对象从流中取出

        ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray());

        ObjectInputStream ois = new ObjectInputStream(bis);

        return (Author) ois.readObject();

    }
}
public class AbsoluteCopying {
    public static void main(String[] args) throws Exception {

        Address address = new Address("南京");
        Author author = new Author("老王", address);
        Author cloneAuthor = author.absoluteClone();
        System.out.println("原作者作者姓名:  " + author.getName() + " 住址:  " + author.getAddress().getLocation());
        System.out.println("克隆作者姓名:  " + cloneAuthor.getName() + " 住址:  " + cloneAuthor.getAddress().getLocation());
        System.out.println("修改原作者姓名为 隔壁老王，住址为 北京");
        author.setName("隔壁老王");
        author.setAddress(new Address("北京"));
        System.out.println("原作者作者姓名:  " + author.getName() + " 住址:  " + author.getAddress().getLocation());
        System.out.println("克隆作者姓名:  " + cloneAuthor.getName() + " 住址:  " + cloneAuthor.getAddress().getLocation());

    }
}
```

### 7、模板方法模式

**模板方法模式**：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构既可以重新定义该算法的某些特定步骤。

把公用方法定义到父类中，具体实现放到子类中。父类的方法去调用子类实现的方法。

```java
//定义一个抽象模板：
public abstract class absClass{
    //抽象方法方法方法放到子类中具体实现
    public abstract void method1();
    public abstract void method2();
    //具体的一些骨架，一些实现方法都是子类去实现
    public void TemplateMethod(){
        method1();
        method2();
    }
}

public class ConcreteClassA extends absClass{
   //具体实现
    public  void method1(){
        
    }
    public  void method2(){
        
    } 
}
//测试类
absClass c = new ConcreteClassA();
c.TemplateMethod();
```

### 8、外观模式

**外观模式**:为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层的接口，这个接口使得这一子系列系统更加容易使用。有一个外观类去对外开放接口，外观类的方法里去对相应的子系统去进行一些操作。实现了对子系统的封闭。

```java
//子系统1
public class SystemOne{
 //子系统的方法
    public void method1(){
     
 }
}
//子系统2
public class SystemTwo{
 //子系统的方法
    public void method2(){
     
 }
}
public class Facade{
    public SystemOne sysOne;
    public SystemOne sysTwo;
    public Facade(){
        sysOne = new SystemOne();
        sysTwo = new SystemTwo();
    }
    public void m1(){
        sysOne.method1();
        sysTwo.method2();
    }
}
pulic class Test{
    public static void main(String[] args){
        Facade facade = new Facade();
        facade.m1();
    }
}
```

### 9、建造者设计模式

**建造者设计模式**： 将一个复杂对象的构建与它的实现分离，使得同样的构建过程可以创建出不同的表示。建造者模式分为几个部分：

Product产品：建造出来的产品

Builder构建者：负责创建产品

Director指挥者：指挥对应的构建者创建对应的产品

```java
//产品类
public class Product {
    List<String> parts = new ArrayList<>();
    //添加产品的零件，组装产品
    public void add(String part){
        parts.add(part);
    }
    //展示产品

    public void show(){
        parts.forEach(System.out::println);
    }
}

//建造者抽象类
public abstract class Builder {
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    public abstract Product getProduct();
}
//建造者实现类
public class ConcertBuilder extends Builder{
    private Product product = new Product();
    @Override
    public void buildPartA() {
        product.add("部件A");
    }

    @Override
    public void buildPartB() {
        product.add("部件B");
    }

    @Override
    public void buildPartC() {
        product.add("部件C");
    }

    @Override
    public Product getProduct() {
        return product;
    }

}
//指挥者：
public class Director {
    private Builder builder;
    public void createProduct(Builder builder){
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Director dir = new Director();
        Builder builder = new ConcertBuilder();
        dir.createProduct(builder);
        Product p = builder.getProduct();
        p.show();
    }
}
```

### 10、观察者设计模式

**观察者设计模式**：发布订阅模式，提供了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象，这个主题对象发生变化时，会通知所有观察者使他们更新自己。主题类就是发送通知的类，一般来说观察者一般用的是抽象类，因为他们大部分都有公用的属性，所以采用抽象类的形式，主题类采用接口的形式，因为每个主题类可能都是风马牛不相及的类。

```java
//抽象主题类
public abstract class Subject {
    //主题类观察的对象集合
    private List<Observer> observers = new ArrayList<>();
    //增加观察者
    public void addObserver(Observer observer){
        observers.add(observer);
    }
    //移除观察者
    public void delObserver(Observer observer){
        observers.remove(observer);
    }
    //通知所有的观察者
    public void notifyObservers(){
        observers.forEach(observer -> {
            observer.update();
        });
    }
}
//具体主题类
public class ConcreteSubject extends Subject{
    private String subjectStatus;

    public String getSubjectStatus() {
        return subjectStatus;
    }

    public void setSubjectStatus(String subjectStatus) {
        this.subjectStatus = subjectStatus;
    }
}
//抽象观察者类
public abstract class Observer {
    //每个观察者收到通知需要做的操作
    public abstract void update();
}
//具体观察者类
public class ConcreteObserver extends Observer{
    private String name;
    private String observerState;
    private ConcreteSubject concreteSubject;

    public ConcreteObserver(ConcreteSubject concreteSubject, String name){
        this.concreteSubject = concreteSubject;
        this.name = name;
    }

    @Override
    public void update() {
        System.out.println("ConcreteObserver 收到通知");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        ConcreteSubject concreteSubject = new ConcreteSubject();
        concreteSubject.addObserver(new ConcreteObserver(concreteSubject,"X"));
        concreteSubject.addObserver(new ConcreteObserver(concreteSubject,"Y"));
        concreteSubject.notifyObservers();
    }
}

```

### 11、抽象工厂模式

**抽象工厂模式**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体的类，和工厂模式不同的是，工厂方法把实例化的权利交给了刻录，而抽象工厂方法内部自己去实现创建工厂 相当于 dao,daoImpl,service,serviceImpl

```java
//PO
public class Department {
    private String id;
}
//操作PO的接口
public interface IDepartment {
    void insert (Department department);
    Department getDepartment(int id);
}
//实现操作该PO的接口 1
public class SqlServerDepartment implements IDepartment{
    @Override
    public void insert(Department department) {
        System.out.println("sqlServer插入一条"+department);
    }

    @Override
    public Department getDepartment(int id) {
        System.out.println("sqlServer得到一条"+"department记录");
        return null;
    }
}
//实现操作该PO的接口 2
public class AccessDepartment implements IDepartment{

    @Override
    public void insert(Department department) {
        System.out.println("accessServer插入一条"+department);
    }

    @Override
    public Department getDepartment(int id) {
        System.out.println("accessServer得到一条"+"department记录");

        return null;
    }
}
//负责返回操作PO实例的接口
public interface IFactory {
    IDepartment createDepartment();
}
//负责返回操作PO实例的实体类
public class SqlServerFactory implements IFactory{
    @Override
    public IDepartment createDepartment() {
        return new SqlServerDepartment();
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        IFactory ifactory = new SqlServerFactory();
        IDepartment iDepartment = ifactory.createDepartment();
        iDepartment.insert(new Department());

    }
}


```

### 12 状态模式

**状态模式**： 解决一个对象有多个状态需要做出不同的表现

```java
//state类
public abstract class State{
    public abstract void Handle();
}
//state具体实现类
public class ConcreteStateA extends State{
     public abstract void Handle(){
         
     } 
}
public class ConcreteStateB extends State{
     public abstract void Handle(){
         
     } 
}

//Context类 用来保存当前对象的状态 和根据不同状态做出改变
public class Context{
    private State state;
    
    public Context(State state){
        this.state = state;
    }
    public void Request(){
        state.Handle();
    }
}
//测试类
public class Test{
    public static void main(String[] args){
        Context context = new Context(具体放入的状态类);
        context.Request();
        
    }
}
```

### 13适配器模式

**适配器模式**:将一个类的接口转为客户希望的另外一个接口， 适配器模式可以使得原本由于接口不兼容而不能再一起工作的类可以一起工作，本质上调用原来的方法，原来的方法不太适用，来一个中转的类 在这个类方法中去调用其他的方法

```java
//原始类的方法
public class Target {
    public void request(){
        System.out.println("普通请求");
    }
}
//要修改的方法
public class Adaptee {
    public void SpecialRequest(){
        System.out.println("特殊的请求");
    }
}
//适配器的类 用适配器的类调用原始的方法去触发修改后的方法
public class Adapter extends Target{
    private Adaptee adaptee = new Adaptee();
    public void Request(){
        adaptee.SpecialRequest();
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Target t = new Adapter();
        t.request();
    }
}

```

### 14、备忘录模式

**备忘录模式**:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可将该对象恢复到原先保存的状态。

```java
//发起人 通过管理者的memento恢复当前对象的状态
public class Originator {
    private String state;
    private Memento memento;
    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
    public Memento createMemento(){
        return new Memento(state);
    }

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
       state = memento.getState();
    }

    @Override
    public String toString() {
        return "Originator{" +
                "state='" + state + '\'' +
                '}';
    }
}
// 备忘录类  负责存储发起人的状态
public class Memento {
    private String state;
    public Memento(String state){
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
//管理者类 负责管理备忘录类
public class Caretaker {
    private Memento memento;

    public Memento getMemento() {
        return this.memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Originator o = new Originator();
        o.setState("On");
        System.out.println(o);
        Caretaker c  = new Caretaker();
        c.setMemento(o.createMemento());
        o.setState("OFF");
        System.out.println(o);


        o.setMemento( c.getMemento());
        System.out.println(o);
    }
}
```

### 15、组合模式

**组合模式**:将对象组合成树形结构以表示部分和整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。相当于一个树形结构。

```java
//树形结构的抽象类，对树的操作 
public abstract class Component {
    protected String name;
    public Component(String name){
        this.name = name;
    }
    public abstract void Add(Component c);
    public abstract void Remove(Component c);
    public abstract void Display(int depth);
}
//叶节点 叶节点只有展示的功能
public class Leaf extends Component{

    public Leaf(String name) {
        super(name);
    }

    @Override
    public void Add(Component c) {
        System.out.println("Cant not add a leaf");
    }

    @Override
    public void Remove(Component c) {
        System.out.println("Cant not remove a leaf");
    }

    @Override
    public void Display(int depth) {
        System.out.println(this.name+":"+depth);
    }

    @Override
    public String toString() {
        return "Leaf{"+this.name+"}";
    }
}
//分支的实现类
public class Composite extends Component {
    private List<Component> children = new ArrayList<>();

    public Composite(String name) {
        super(name);
    }

    @Override
    public void Add(Component c) {
        children.add(c);
    }

    @Override
    public void Remove(Component c) {
        children.remove(c);
    }
	
    //当加入的是其他枝干的时候递归调用display
    @Override
    public void Display(int depth) {
        System.out.println(this.name+"-----------------"+depth++);
        int finalDepth = depth;
        children.forEach(child->{
            child.Display(finalDepth);
        });
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        //创建一个根节点 添加两个叶子节点
        Composite c = new Composite("root");
        c.Add(new Leaf("Leaf A"));
        c.Add(new Leaf("Leaf B"));
		//创建一个支干1
        Composite comp = new Composite("rootA");
        comp.Add(new Leaf("Leaf XA"));
        comp.Add(new Leaf("Leaf XB"));
		//把该枝干加入到根节点
        c.Add(comp);
		//创建一个支干2
        Composite comp2 = new Composite("rootB");
        comp2.Add(new Leaf("Leaf XYA"));
        comp2.Add(new Leaf("Leaf XYB"));
		//把枝干2加入到枝干1
        comp.Add(comp2);
		//遍历该树当加入枝干的时候 枝干的display 也是去遍历枝干里的叶子节点相当于递归调用
        c.Display(1);

    }
}
```

### 16、迭代器模式

**迭代器模式**:提供一中方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

```java
//迭代器接口（用接口的原因就是因为迭代器的实现不止一种有正向还有反向）
  public interface IIterator {
    public abstract Object first();
    public abstract Object next();
    public abstract Boolean isDone();
    public abstract Object currentItem();
}
//创建出需要迭代的类的抽象类，返回迭代方法
public abstract class AbsAggregate {
    public abstract IIterator createIterator();
}
//需要迭代的具体类
public class ConcreteAggregate extends AbsAggregate {
    private List<Object> items = new ArrayList<>(5);

    @Override
    public IIterator createIterator() {
        return new ConcreteIterator(this);
    }
    public int getCount(){
        return items.size();
    }
    public Object getObject(int index){
        return items.get(index);
    }
    public void setObject(Object val){
         items.add(val);
    }
}
//正向迭代器的具体实现
public class ConcreteIterator implements IIterator{
    private ConcreteAggregate aggregate;
    private int current = 0;
    public ConcreteIterator (ConcreteAggregate aggregate){
        this.aggregate = aggregate;
    }
    @Override
    public Object first() {
       return aggregate.getObject(0);
    }

    @Override
    public Object next() {
      current++;
      if(current<aggregate.getCount()){
          return aggregate.getObject(current);
      }
      return "没有元素";
    }

    @Override
    public Boolean isDone() {
       return current >= aggregate.getCount()?true:false;
    }

    @Override
    public Object currentItem() {
        return aggregate.getObject(current);
    }
}
//反向迭代器的具体实现
public class ConcreteIteratorDesc implements IIterator {
    private ConcreteAggregate concreteAggregate;
    private int current = 0;

    public ConcreteIteratorDesc(ConcreteAggregate concreteAggregate, int current) {
        this.concreteAggregate = concreteAggregate;
        this.current = concreteAggregate.getCount() - 1;
    }

    @Override
    public Object first() {
        return concreteAggregate.getObject(concreteAggregate.getCount() - 1);
    }

    @Override
    public Object next() {
       if(this.current >=0){
           return concreteAggregate.getObject(this.current--);
       }
       return "null";
    }

    @Override
    public Boolean isDone() {
        return this.current < 0 ? true : false;
    }

    @Override
    public Object currentItem() {
        return concreteAggregate.getObject(this.current);
    }
}

//测试类
public class Test {
    public static void main(String[] args) {
        ConcreteAggregate aggregate = new ConcreteAggregate();
        for (int i = 0; i < 5; i++) {
            aggregate.setObject(i);
        }
        IIterator iterator = aggregate.createIterator();
        while(!iterator.isDone()){
            System.out.println(iterator.next());
        }
    }
}
```

### 17、单例模式

**单例模式**：保证一个类只有一个实例，并且提供一个访问它的全局访问点，让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以创建。

```java
//懒汉式（懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。） 优点:节省内存空间,缺点:线程不安全
public class Singleton {
    private static Singleton instance;
    private Singleton() {

    }
    public static Singleton getInstance() {
        if (null == instance) {
            instance = new Singleton();
        }
        return instance;
    }
}
//饿汉式（饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。）
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {

    }
    public static Singleton getInstance() {
        return instance;
    }
}
//饿汉式加锁（采用懒汉式＋数据同步的方法既满足了懒加载又能够100%保证instance实例的唯一性。但是，synchronized关键字的排它性会导致getInstance()方法同一时刻只能被一个线程访问，性能会比较低下。）
public class Singleton {
    private static Singleton instance;

    private Singleton() {

    }
    public static Singleton getInstance() {
        if (instance == null) {
             instance = new Singleton();
          }
        return instance;
    }
}
//饿汉式双重检测（synchronized锁类名相当于锁当前类的所有对象，有两个ifif (null == instance)条件判断，因为两个线程同时进入的时候线程A实例化了一个instance，线程B通过了第一个if，当线程A实例化后，线程B再次判断一下 起到了双重加锁的作用）
public class Singleton {
    private static Singleton instance;

    private Singleton() {

    }
    public static Singleton getInstance() {
        if (null == instance) {
            synchronized (Singleton.class){
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
//静态内部类实现(第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。静态内部类的加载不需要依附外部类，在使用时才加载。不过在加载静态内部类的过程中也会加载外部类)
public class Singleton { 
    private Singleton(){
    }
      public static Singleton getInstance(){  
        return SingletonHolder.sInstance;  
    }  
    private static class SingletonHolder {  
        private static final Singleton sInstance = new Singleton();  
    }  
} 
//使用容器实现单例模式(用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。)
public class SingletonManager { 
　　private static Map<String, Object> objMap = new HashMap<String,Object>();
　　private Singleton() { 
　　}
　　public static void registerService(String key, Objectinstance) {
　　　　if (!objMap.containsKey(key) ) {
　　　　　　objMap.put(key, instance) ;
　　　　}
　　}
　　public static ObjectgetService(String key) {
　　　　return objMap.get(key) ;
　　}
}
//枚举类实现(枚举方式在很多开源框架中也应用得比较广泛，枚举类型不允许被继承，同样是线程安全的，并且只能被实例化一次，但是枚举类型不能够实现懒加载)
public class SingletonEnum {
    //实例变量
    private byte[] data = new byte[1024];

    private SingletonEnum() {

    }

    //使用枚举充当Holder
    private enum EnumHolder {
        INSTANCE;
        private SingletonEnum instance;

        EnumHolder() {
            this.instance = new SingletonEnum();
        }

        private SingletonEnum getInstance() {
            return instance;
        }
    }

    public static SingletonEnum getInstance() {
        return EnumHolder.INSTANCE.getInstance();
    }
}
```



### 18、桥接模式

**桥接模式**：将抽象部分与他的实现部分分离，使它们都可以独立地变化。（抽象与它的实现分离，并不是说让抽象类与派生类分离，实现指的是抽象类和它的派生类用来实现自己的对象），主要类与类之间的分离，如果继承太多那就不太适合抽离，需要桥接。需要把类内聚或者聚合到其他的类里，防止过度的派生。

```java
//Implementor类的实现
public abstract class Implementor {
    public abstract void operation();
}
public class ConcreteImplementorA extends Implementor {
    @Override
    public void operation() {
        System.out.println("具体A的实现");
    }
}
public class ConcreteImplementorB extends Implementor {
    @Override
    public void operation() {
        System.out.println("具体B的实现");
    }
}
//Abstraction类的实现
public class Abstraction {
    protected Implementor implementor;

    public void setImplementor(Implementor implementor) {
        this.implementor = implementor;
    }
    public void Operation(){
        implementor.operation();
    }
}
public class RefinedAbstraction extends Abstraction{
    @Override
    public void Operation() {
        super.Operation();
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Abstraction abstraction = new RefinedAbstraction();
        abstraction.setImplementor(new ConcreteImplementorA());
        abstraction.Operation();
        abstraction.setImplementor(new ConcreteImplementorB());
        abstraction.Operation();
    }
}
```

### 19、命令模式

**命令模式**：将一个请求封装成为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。命令模式由命令类，接受者，调用者组成

```java
//命名类
public abstract class Command {
    protected Receiver receiver;

    public Command(Receiver receiver) {
        this.receiver = receiver;
    }
    public abstract void execute();
}

//具体命名类，用来绑定命令的执行与调用者的执行
public class ConcreteCommand extends Command{
    public ConcreteCommand(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void execute() {
        receiver.action();
    }
}
//发起命令的调用方
public class Invoker {
    //private Command command;
	private List<Command> commands;
    public void setCommand(Command command) {
        this.command = command;
        this.commands = new ArrayList();
    }
    public void addCommand(Command command){
        this.commands.add(command);
    }
    public void removeCommand(Command command){
        this.commands.remove(command);
    }
    public void ExecuteCommand(){
       commands.foreach(command-{command.execute()})
        // command.execute();
    }
}
//接受命令的接受者
public class Receiver {
    public void action(){
        System.out.println("执行请求 ！");
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        Command command = new ConcreteCommand(receiver);
        Invoker invoker = new Invoker();
        invoker.setCommand(command);
        invoker.ExecuteCommand();
    }
}

```

### 20、职责链模式

**职责链模式**：使多个对象都有机会处理请求从而避免请求的发送者和接受者之间有一定的耦合关系，将这个对象形成一条链，并沿着这条链传递该请求，直道有一个对象处理它为止，请求发起者不用管是谁处理该请求，总有一个类去处理该请求。处理者必须保持着下一个处理者的引用，才能够让下一处理者处理请求。

```java
//处理者抽象类
public abstract class Handler {
    //下一个处理人
    protected Handler handler;
    public void setSuccessor(Handler successor){
        this.handler = successor;
    }
    public abstract void handleRequest(int request);
}
//处理者具体实现
public class ConcreHandler1 extends Handler{

    @Override
    public void handleRequest(int request) {
        //如果request在1和10之间处理请求 否则移交给下一节点处理
        if(request>=0&&request<=10){
            System.out.println("1处理请求");
        }else{
            handler.handleRequest(request);
        }
    }
}
public class ConcreHandler2 extends Handler {

    @Override
    public void handleRequest(int request) {
        if(request>=10&&request<=20){
            System.out.println("2处理请求");
        }else{
            handler.handleRequest(request);
        }
    }
}
public class ConcreHandler3 extends Handler{

    @Override
    public void handleRequest(int request) {
        System.out.println("3处理请求"+request);
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Handler h1 = new ConcreHandler1();
        Handler h2 = new ConcreHandler2();
        Handler h3 = new ConcreHandler3();
        h1.setSuccessor(h2);
        h2.setSuccessor(h3);

        h1.handleRequest(9);
        h1.handleRequest(11);
        h1.handleRequest(21);
    }
}

```

### 21、中介者模式

**中介者模式**:用一中介对象来封装一系列的对象交互，中介者使各对象不需要显式的相互调用，从而使其耦合松散，而且可以独立的改变他们之间的交互。一般用于一组对象以定义良好但是复杂的方式进行通信的场合。

```java
//中介者抽象类
public abstract class Mediator {
    public abstract void send(String message,Colleague colleague);
}
//同事抽象类
public abstract class Colleague {
    protected Mediator mediator;

    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
}
//中介者具体实现
public class ConcreteMediator extends Mediator{
    // 同事1 同事2
    private ConcreteColleague1 colleague1;
    private ConcreteColleague2 colleague2;

    public ConcreteColleague1 getColleague1() {
        return colleague1;
    }

    public void setColleague1(ConcreteColleague1 colleague1) {
        this.colleague1 = colleague1;
    }

    public ConcreteColleague2 getColleague2() {
        return colleague2;
    }

    public void setColleague2(ConcreteColleague2 colleague2) {
        this.colleague2 = colleague2;
    }
	
    @Override
    public void send(String message, Colleague colleague) {
        if(colleague==colleague1){
            colleague2.notify(message);
        }else{
            colleague1.notify(message);
        }
    }
}
//同事一具体实现
public class ConcreteColleague1 extends Colleague{

    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }
    public void send(String message){
        mediator.send(message,this);
    }
    public void notify(String message){
        System.out.println("同事一得到消息"+message);
    }
}
//同事二具体实现
public class ConcreteColleague2 extends Colleague{
    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }
    public void send(String message){
        mediator.send(message,this);
    }
    public void notify(String message){
        System.out.println("同事二得到消息"+message);
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        ConcreteMediator m = new ConcreteMediator();
        //同事类认识中介者类
        ConcreteColleague1 c1 = new ConcreteColleague1(m);
        ConcreteColleague2 c2 = new ConcreteColleague2(m);
		// 中介者介绍两个人认识
        m.setColleague1(c1);
        m.setColleague2(c2);
        c1.send("吃饭了吗");
        c2.send("没有呢");
    }
}

```

### 22、享元模式

**享元模式**：运用共享技术有效的支持大量细粒度的对象，对象的复用



```java
//要共享的享元抽象类
public abstract class FlyWeight {
    public abstract void operation(int extrinsicstate);
}
//具体的享元类
public class ConcreteFlyWeight extends FlyWeight{
    @Override
    public void operation(int extrinsicstate) {
        System.out.println("具体的flyweight"+extrinsicstate);
    }
}
//享元工厂
public class FlyWeightFactory {
    private Hashtable<String,FlyWeight> hashtable = new Hashtable();
	//初始化
    public FlyWeightFactory() {
        hashtable.put("X",new ConcreteFlyWeight());
        hashtable.put("Y",new ConcreteFlyWeight());
        hashtable.put("Z",new ConcreteFlyWeight());
    }
    public FlyWeight getFlyWeight(String key){
        return hashtable.get(key);
    }
    //不初始化
    public FlyWeight getFlyWeight(String key){
        if(!hashtable.containsKey(key)){
            hashtable.put(key,new ConcreteFlyWeight()); 
        }
        return hashtable.get(key);
    }
}
//不需要共享的享元类
public class UnsharedConcreteFlyWeight extends FlyWeight{
    @Override
    public void operation(int extrinsicstate) {
        System.out.println("不需要共享的"+extrinsicstate);
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        //享元类状态 根据不同状态做出不同的回应（因为对象是共享的，所以需要根据状态去让对象做出不同的响应）
        int extrinsicstate = 22;
        FlyWeightFactory factory = new FlyWeightFactory();

        FlyWeight fx = factory.getFlyWeight("X");
        fx.operation(--extrinsicstate);

        FlyWeight fy = factory.getFlyWeight("Y");
        fy.operation(--extrinsicstate);

        FlyWeight fz = factory.getFlyWeight("Z");
        fz.operation(--extrinsicstate);

        FlyWeight uf = new UnsharedConcreteFlyWeight();
        uf.operation(--extrinsicstate);

    }
}

```

### 23、解释器模式：

**解释器模式**:给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。



```java
//抽象解释器类
public abstract class AbstractExpression {
    public abstract void interpret(Context context);
}
//解释器实现类（实现的方法可以根据需要自己加）
public class NotTerminalExpression extends AbstractExpression{
    @Override
    public void interpret(Context context) {
        System.out.println("非终端解释器");
    }
}
public class TerminalExpression extends AbstractExpression{
    @Override
    public void interpret(Context context) {
        System.out.println("终端解释器");
    }
}
//文本类 要解释的文本类
public class Context {
    private String input;
    public String Input;

    private String output;
    public String Output;

    public String getInput() {
        return input;
    }

    public void setInput(String input) {
        this.input = input;
    }

    public String getOutput() {
        return output;
    }

    public void setOutput(String output) {
        this.output = output;
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        Context context = new Context();
        List<AbstractExpression> lists = new ArrayList<>();
        lists.add(new TerminalExpression());
        lists.add(new NotTerminalExpression());
        lists.add(new TerminalExpression());
        lists.add(new TerminalExpression());
        lists.forEach(abstractExpression -> abstractExpression.interpret(context));
    }

}


```

### 24、访问者模式



**访问者模式**：表示一个作用于某对象结构中各元素的操作，它使你在可以不改变各元素的类的前提下定义这些元素的新操作。

Element：人

Visitor:状态

ObjectStructure：对象结构

```java
//人的抽象类
public abstract class Element {
    public abstract void accept(Visitor visitor);
}
//人的具体实现类 男人 女人
public class ConcreteElementA extends Element{
    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementA(this);
    }
    public void operationA(){

    }
}
public class ConcreteElementB extends Element{
    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementB(this);
    }
    public void operationB(){

    }
}
//状态的抽象类
public abstract class Visitor {
    public abstract void visitConcreteElementA(ConcreteElementA concreteElementA);
    public abstract void visitConcreteElementB(ConcreteElementB concreteElementB);
}
//状态类的具体实现（成功，失败，喜悦，每一个实现类对应一种状态，参数为人的具体实现类：人得到了这个状态做出什么反应）
public class ConcreteVisitor1 extends Visitor{
    @Override
    public void visitConcreteElementA(ConcreteElementA concreteElementA) {
        System.out.println("ConcreteVisitor1     visitConcreteElementA被访问");
    }

    @Override
    public void visitConcreteElementB(ConcreteElementB concreteElementB) {
        System.out.println("ConcreteVisitor1          visitConcreteElementB被访问");
    }
}

public class ConcreteVisitor2 extends Visitor{
    @Override
    public void visitConcreteElementA(ConcreteElementA concreteElementA) {
        System.out.println("ConcreteVisitor2     visitConcreteElementA被访问");
    }

    @Override
    public void visitConcreteElementB(ConcreteElementB concreteElementB) {
        System.out.println("ConcreteVisitor2     visitConcreteElementB被访问");
    }
}
//对象的抽象结构
public class ObjectStructure {
    private List<Element> elements = new ArrayList<>();
    public void attach(Element element){
        elements.add(element);
    }
    public void detach(Element element) {
        elements.remove(element);
    }
    //让人根据状态做出不同的响应
    public void accept(Visitor visitor){
        elements.forEach(element -> element.accept(visitor));
    }
}
//测试类
public class Test {
    public static void main(String[] args) {
        ObjectStructure objectStructure = new ObjectStructure();
        objectStructure.attach(new ConcreteElementA());
        objectStructure.attach(new ConcreteElementB());
        ConcreteVisitor1 v1 = new ConcreteVisitor1();
        ConcreteVisitor2 v2 = new ConcreteVisitor2();
        objectStructure.accept(v1);
        objectStructure.accept(v2);
    }
}
```



### 类的设计原则

#### 1.单一职责原则：

就一个类而言，应该仅有一个引起它变化的原因。 类似于方块游戏的设计，把设计的功能通过每个类分隔开，每个类各司其职，做自己的事方便了代码的解耦。

#### 2.开闭原则：

软件实体（类，函数，模块等等）应该是可以扩展的，但是不应该修改。类似于计算器设计的类（第一章简单工厂模式），如果再加一些相应的功能，比如求平方根等等功能，原有类无需做任何的改变，只需要增加一个新的类去扩展即可。体现了开放封闭原则。

#### 3.依赖倒转原则：

A.高层模块不应该依赖低层模块。两个都应该依赖抽象。

B.抽象不应该依赖细节。细节应该依赖抽象。

举例：依赖倒转主要是针对接口编程，不要针对实现编程。无论主板,PC，内存，硬盘。都是在针对接口设计，如果针对实现来设计，需要具体到某一个品牌。比如，我们做的项目大部分都要访问数据库，所以我们把访问数据库写成了函数，方便高层函数去调用。问题出现了，如果高层模块需要调用一些其他的数据库去处理一些逻辑。

**里氏代换准则**：子类型必须能够替换掉他们的父类型。一个软件实体如果使用的是一个父类的话，那么其一定试用其子类，而且它察觉不出父类对象和子类对象的区别。简单来说，在软件里，把父类都换成子类，程序的行为没有发生变化。

因为有了这个原，父类才能够被真正的复用，而子类也能够在父类的基础上增加新的行为。

#### 4.迪米特法则（最少知道原则）:

如果两个类不必彼此之间直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。

#### 5、合成/聚合复用原则：

尽量使用合成/聚合，尽量不要使用类继承。聚合是一种弱的拥有关系，体现的是A对象可以包含对象B，但是对象B不是对象A的一部分。合成这是一种强的拥有关系。

```java
//聚合：A中可能有B对象，B对象不是A的一部分
class A{
private ArrayList<B> bs;
}
class B{
}
//合成：A中一定有B对象，并且生成A对象的同时一定生成B对象

class A{
private B b；
public A（）{
  b=new B（）；
}
}

class B{
}
```









